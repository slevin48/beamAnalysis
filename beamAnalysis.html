<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Beam Stress Analysis - PDE Toolbox</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            height: 100vh;
            overflow: hidden;
        }
        .container {
            display: grid;
            grid-template-columns: 320px 1fr;
            height: 100vh;
        }
        .sidebar {
            background: rgba(255,255,255,0.05);
            padding: 15px;
            overflow-y: auto;
            border-right: 1px solid rgba(255,255,255,0.1);
        }
        .main-content { display: flex; flex-direction: column; }
        .toolbar {
            background: rgba(255,255,255,0.05);
            padding: 10px 20px;
            display: flex;
            gap: 10px;
            align-items: center;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .viewer-container { flex: 1; position: relative; }
        #canvas3d { width: 100%; height: 100%; display: block; }
        .status-bar {
            background: rgba(0,0,0,0.3);
            padding: 8px 20px;
            font-size: 12px;
            color: #888;
            display: flex;
            justify-content: space-between;
        }
        h2 {
            font-size: 14px;
            color: #4fc3f7;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(79,195,247,0.3);
            text-transform: uppercase;
        }
        .section {
            margin-bottom: 20px;
            background: rgba(255,255,255,0.03);
            padding: 15px;
            border-radius: 8px;
        }
        .form-group { margin-bottom: 12px; }
        label {
            display: block;
            font-size: 11px;
            color: #aaa;
            margin-bottom: 4px;
            text-transform: uppercase;
        }
        input[type="number"], select {
            width: 100%;
            padding: 8px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 4px;
            background: rgba(0,0,0,0.3);
            color: #fff;
            font-size: 13px;
        }
        input:focus, select:focus {
            outline: none;
            border-color: #4fc3f7;
        }
        .input-row {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            transition: all 0.2s;
        }
        .btn-primary { background: linear-gradient(135deg, #4fc3f7, #29b6f6); color: #000; }
        .btn-success { background: linear-gradient(135deg, #66bb6a, #43a047); color: #fff; }
        .btn-warning { background: linear-gradient(135deg, #ffa726, #fb8c00); color: #000; }
        .btn-secondary { background: rgba(255,255,255,0.1); color: #fff; border: 1px solid rgba(255,255,255,0.2); }
        .btn-block { width: 100%; margin-top: 10px; }
        button:hover { transform: translateY(-1px); opacity: 0.9; }
        .bc-list, .load-list {
            max-height: 100px;
            overflow-y: auto;
            background: rgba(0,0,0,0.2);
            border-radius: 4px;
            padding: 8px;
            margin-top: 8px;
        }
        .bc-item, .load-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 8px;
            background: rgba(255,255,255,0.05);
            border-radius: 4px;
            margin-bottom: 4px;
            font-size: 11px;
        }
        .remove-btn {
            background: #ef5350;
            color: #fff;
            border: none;
            padding: 2px 6px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
        }
        .results-panel {
            display: none;
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
        }
        .results-panel.visible { display: block; }
        .result-value { font-size: 18px; font-weight: bold; color: #4fc3f7; }
        .result-unit { font-size: 11px; color: #888; }
        .info-text { font-size: 10px; color: #666; margin-top: 3px; }
        .colorbar {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            width: 25px;
            height: 180px;
            background: linear-gradient(to top, #0000ff, #00ffff, #00ff00, #ffff00, #ff0000);
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.3);
            display: none;
        }
        .colorbar.visible { display: block; }
        .colorbar-labels {
            position: absolute;
            right: 50px;
            top: 50%;
            transform: translateY(-50%);
            height: 180px;
            display: none;
            flex-direction: column;
            justify-content: space-between;
            font-size: 10px;
        }
        .colorbar-labels.visible { display: flex; }
        .view-controls {
            position: absolute;
            bottom: 15px;
            left: 15px;
            display: flex;
            gap: 5px;
        }
        .view-btn {
            padding: 6px 10px;
            background: rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.2);
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
        }
        .view-btn:hover { background: rgba(79,195,247,0.3); }
        .loading-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 100;
        }
        .loading-overlay.visible { display: flex; }
        .spinner {
            width: 40px; height: 40px;
            border: 4px solid rgba(79,195,247,0.2);
            border-top: 4px solid #4fc3f7;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }
        .loading-text { margin-top: 10px; color: #4fc3f7; }
        .connection-status {
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 10px;
            margin-left: 10px;
        }
        .connected { background: #43a047; }
        .disconnected { background: #ef5350; }
        .display-options { display: flex; gap: 15px; margin-top: 10px; }
        .checkbox-group { display: flex; align-items: center; gap: 5px; font-size: 11px; }
        .checkbox-group input { width: auto; }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <div class="section">
                <h2>Beam Geometry</h2>
                <div class="form-group">
                    <label>Dimensions (m)</label>
                    <div class="input-row">
                        <div><input type="number" id="beamLength" value="1.0" step="0.1" min="0.1"><div class="info-text">Length</div></div>
                        <div><input type="number" id="beamWidth" value="0.1" step="0.01" min="0.01"><div class="info-text">Width</div></div>
                        <div><input type="number" id="beamHeight" value="0.05" step="0.01" min="0.01"><div class="info-text">Height</div></div>
                    </div>
                </div>
                <button class="btn-primary btn-block" id="createBeamBtn">Create Beam</button>
            </div>

            <div class="section">
                <h2>Material Properties</h2>
                <div class="form-group">
                    <label>Material Preset</label>
                    <select id="materialPreset">
                        <option value="steel">Steel</option>
                        <option value="aluminum">Aluminum</option>
                        <option value="copper">Copper</option>
                        <option value="titanium">Titanium</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Young's Modulus (Pa)</label>
                    <input type="number" id="youngsModulus" value="210e9">
                </div>
                <div class="form-group">
                    <label>Poisson's Ratio</label>
                    <input type="number" id="poissonsRatio" value="0.3" step="0.01" min="0" max="0.5">
                </div>
            </div>

            <div class="section">
                <h2>Boundary Conditions</h2>
                <div class="form-group">
                    <label>Face to Fix</label>
                    <select id="bcFace">
                        <option value="left">Left Face (x=0)</option>
                        <option value="right">Right Face (x=L)</option>
                        <option value="bottom">Bottom Face (z=0)</option>
                        <option value="top">Top Face (z=H)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Constraint Type</label>
                    <select id="bcType">
                        <option value="fixed">Fixed (All DOF)</option>
                        <option value="roller">Roller</option>
                    </select>
                </div>
                <button class="btn-warning btn-block" id="addBCBtn">Add Constraint</button>
                <div class="bc-list" id="bcList"></div>
            </div>

            <div class="section">
                <h2>Applied Loads</h2>
                <div class="form-group">
                    <label>Apply to Face</label>
                    <select id="loadFace">
                        <option value="right">Right Face (x=L)</option>
                        <option value="top">Top Face (z=H)</option>
                        <option value="bottom">Bottom Face (z=0)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Force Components (N)</label>
                    <div class="input-row">
                        <div><input type="number" id="forceX" value="0" step="100"><div class="info-text">Fx</div></div>
                        <div><input type="number" id="forceY" value="0" step="100"><div class="info-text">Fy</div></div>
                        <div><input type="number" id="forceZ" value="-10000" step="100"><div class="info-text">Fz</div></div>
                    </div>
                </div>
                <button class="btn-warning btn-block" id="addLoadBtn">Add Load</button>
                <div class="load-list" id="loadList"></div>
            </div>

            <div class="section">
                <h2>Mesh Settings</h2>
                <div class="form-group">
                    <label>Mesh Size</label>
                    <select id="meshSize">
                        <option value="coarse">Coarse</option>
                        <option value="medium" selected>Medium</option>
                        <option value="fine">Fine</option>
                    </select>
                </div>
            </div>

            <button class="btn-success btn-block" id="runAnalysisBtn" style="font-size: 14px; padding: 15px;">
                Run Analysis
            </button>

            <div class="results-panel" id="resultsPanel">
                <h2>Results</h2>
                <div class="form-group">
                    <label>Max Displacement</label>
                    <div class="result-value" id="maxDisp">--</div>
                    <span class="result-unit">mm</span>
                </div>
                <div class="form-group">
                    <label>Max von Mises Stress</label>
                    <div class="result-value" id="maxStress">--</div>
                    <span class="result-unit">MPa</span>
                </div>
                <div class="display-options">
                    <div class="checkbox-group">
                        <input type="checkbox" id="showDeformed" checked>
                        <label for="showDeformed">Deformed</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="showWireframe">
                        <label for="showWireframe">Wireframe</label>
                    </div>
                </div>
                <div class="form-group" style="margin-top: 10px;">
                    <label>Scale: <span id="scaleValue">10</span>x</label>
                    <input type="range" id="defScale" min="1" max="100" value="10" style="width:100%">
                </div>
            </div>
        </div>

        <div class="main-content">
            <div class="toolbar">
                <button class="btn-secondary" id="resetViewBtn">Reset View</button>
                <span style="flex:1"></span>
                <span id="modeIndicator" style="color:#4fc3f7">Mode: Setup</span>
                <span id="connectionStatus" class="connection-status disconnected">Disconnected</span>
            </div>
            <div class="viewer-container">
                <canvas id="canvas3d"></canvas>
                <div class="colorbar" id="colorbar"></div>
                <div class="colorbar-labels" id="colorbarLabels">
                    <span id="cbMax">Max</span>
                    <span id="cbMid">Mid</span>
                    <span id="cbMin">Min</span>
                </div>
                <div class="view-controls">
                    <button class="view-btn" id="viewFront">Front</button>
                    <button class="view-btn" id="viewTop">Top</button>
                    <button class="view-btn" id="viewIso">Iso</button>
                </div>
                <div class="loading-overlay" id="loadingOverlay">
                    <div class="spinner"></div>
                    <div class="loading-text">Solving FEM...</div>
                </div>
            </div>
            <div class="status-bar">
                <span id="statusText">Ready - Create a beam to begin</span>
                <span id="meshInfo">Nodes: 0 | Elements: 0</span>
            </div>
        </div>
    </div>

    <script>
        // State
        let beamCreated = false, boundaryConditions = [], loads = [], currentResults = null, htmlComponent = null;
        let canvas, ctx;
        let viewAngleX = 0.5, viewAngleY = 0.3, viewDist = 3;
        let beamDims = { L: 1, W: 0.1, H: 0.05 };
        let isDragging = false, lastMouse = { x: 0, y: 0 };

        const materials = {
            steel: { E: 210e9, nu: 0.3 },
            aluminum: { E: 69e9, nu: 0.33 },
            copper: { E: 110e9, nu: 0.34 },
            titanium: { E: 116e9, nu: 0.32 }
        };

        // 3D projection
        function project(x, y, z) {
            const cosX = Math.cos(viewAngleX), sinX = Math.sin(viewAngleX);
            const cosY = Math.cos(viewAngleY), sinY = Math.sin(viewAngleY);
            let x1 = x * cosY - z * sinY;
            let z1 = x * sinY + z * cosY;
            let y1 = y * cosX - z1 * sinX;
            let z2 = y * sinX + z1 * cosX;
            const scale = 300 / (viewDist + z2 * 0.5);
            return { x: canvas.width/2 + x1 * scale, y: canvas.height/2 - y1 * scale, z: z2 };
        }

        function drawLine(p1, p2, color, width) {
            ctx.strokeStyle = color;
            ctx.lineWidth = width || 1;
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        }

        function drawBeam() {
            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1;
            for (let i = -10; i <= 10; i++) {
                const p1 = project(i * 0.1, 0, -1);
                const p2 = project(i * 0.1, 0, 1);
                drawLine(p1, p2, '#222', 0.5);
                const p3 = project(-1, 0, i * 0.1);
                const p4 = project(1, 0, i * 0.1);
                drawLine(p3, p4, '#222', 0.5);
            }

            // Draw axes
            const origin = project(0, 0, 0);
            drawLine(origin, project(0.3, 0, 0), '#ff4444', 2);
            drawLine(origin, project(0, 0.3, 0), '#44ff44', 2);
            drawLine(origin, project(0, 0, 0.3), '#4444ff', 2);

            if (!beamCreated) return;

            const L = beamDims.L, W = beamDims.W, H = beamDims.H;
            const cx = L/2, cy = W/2, cz = H/2;

            // Beam vertices (centered)
            const verts = [
                [0-cx, 0-cy, 0-cz], [L-cx, 0-cy, 0-cz], [L-cx, W-cy, 0-cz], [0-cx, W-cy, 0-cz],
                [0-cx, 0-cy, H-cz], [L-cx, 0-cy, H-cz], [L-cx, W-cy, H-cz], [0-cx, W-cy, H-cz]
            ];

            // Project vertices
            const projected = verts.map(v => project(v[0], v[2], v[1]));

            // Draw faces with depth sorting
            const faces = [
                { verts: [0,1,2,3], color: currentResults ? null : '#5577aa' }, // bottom
                { verts: [4,5,6,7], color: currentResults ? null : '#7799cc' }, // top
                { verts: [0,1,5,4], color: currentResults ? null : '#6688bb' }, // front
                { verts: [2,3,7,6], color: currentResults ? null : '#6688bb' }, // back
                { verts: [0,3,7,4], color: currentResults ? null : '#5588aa' }, // left
                { verts: [1,2,6,5], color: currentResults ? null : '#5588aa' }  // right
            ];

            // Calculate face depths and sort
            faces.forEach(f => {
                f.depth = f.verts.reduce((sum, i) => sum + projected[i].z, 0) / 4;
            });
            faces.sort((a, b) => b.depth - a.depth);

            // Draw faces
            faces.forEach(face => {
                ctx.beginPath();
                ctx.moveTo(projected[face.verts[0]].x, projected[face.verts[0]].y);
                for (let i = 1; i < face.verts.length; i++) {
                    ctx.lineTo(projected[face.verts[i]].x, projected[face.verts[i]].y);
                }
                ctx.closePath();

                if (currentResults) {
                    // Color based on stress (simplified)
                    const t = 0.5; // Middle value for now
                    ctx.fillStyle = getStressColor(t);
                } else {
                    ctx.fillStyle = face.color;
                }
                ctx.globalAlpha = 0.85;
                ctx.fill();
                ctx.globalAlpha = 1;
                ctx.strokeStyle = '#334';
                ctx.lineWidth = 1;
                ctx.stroke();
            });

            // Draw BC indicators
            boundaryConditions.forEach(bc => {
                if (bc.face === 'left') {
                    const p = project(-cx, 0, 0);
                    ctx.fillStyle = '#ff8800';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#fff';
                    ctx.font = '10px Arial';
                    ctx.fillText('F', p.x - 3, p.y + 3);
                }
            });

            // Draw load arrows
            loads.forEach(load => {
                if (load.face === 'right') {
                    const p = project(L-cx, 0, 0);
                    ctx.strokeStyle = '#ff4444';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(p.x + 30, p.y);
                    ctx.lineTo(p.x, p.y);
                    ctx.lineTo(p.x + 10, p.y - 8);
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(p.x + 10, p.y + 8);
                    ctx.stroke();
                }
            });
        }

        function getStressColor(t) {
            t = Math.max(0, Math.min(1, t));
            let r, g, b;
            if (t < 0.25) { r = 0; g = t * 4; b = 1; }
            else if (t < 0.5) { r = 0; g = 1; b = 1 - (t - 0.25) * 4; }
            else if (t < 0.75) { r = (t - 0.5) * 4; g = 1; b = 0; }
            else { r = 1; g = 1 - (t - 0.75) * 4; b = 0; }
            return `rgb(${Math.round(r*255)},${Math.round(g*255)},${Math.round(b*255)})`;
        }

        function drawResultsMesh(results) {
            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (!results || !results.triangles) { drawBeam(); return; }

            const showDeformed = document.getElementById('showDeformed').checked;
            const scale = showDeformed ? parseFloat(document.getElementById('defScale').value) : 0;
            const wireframe = document.getElementById('showWireframe').checked;

            const nodes = results.nodes;
            const tris = results.triangles;
            const stress = results.nodeStress;
            const disp = results.displacement;
            const minS = results.minVonMises, maxS = results.maxVonMises;

            // Center the mesh
            let cx = 0, cy = 0, cz = 0, count = nodes.length / 3;
            for (let i = 0; i < count; i++) {
                cx += nodes[i*3]; cy += nodes[i*3+1]; cz += nodes[i*3+2];
            }
            cx /= count; cy /= count; cz /= count;

            // Project all nodes
            const projected = [];
            for (let i = 0; i < count; i++) {
                const x = nodes[i*3] - cx + scale * (disp[i*3] || 0);
                const y = nodes[i*3+1] - cy + scale * (disp[i*3+1] || 0);
                const z = nodes[i*3+2] - cz + scale * (disp[i*3+2] || 0);
                projected.push(project(x, z, y));
            }

            // Collect triangles with depth
            const triangles = [];
            for (let i = 0; i < tris.length; i += 3) {
                const i0 = tris[i] - 1, i1 = tris[i+1] - 1, i2 = tris[i+2] - 1;
                if (i0 < 0 || i1 < 0 || i2 < 0 || i0 >= count || i1 >= count || i2 >= count) continue;
                const depth = (projected[i0].z + projected[i1].z + projected[i2].z) / 3;
                const avgStress = (stress[i0] + stress[i1] + stress[i2]) / 3;
                const t = (avgStress - minS) / (maxS - minS + 1e-10);
                triangles.push({ i0, i1, i2, depth, color: getStressColor(t) });
            }

            // Sort by depth
            triangles.sort((a, b) => b.depth - a.depth);

            // Draw triangles
            triangles.forEach(tri => {
                const p0 = projected[tri.i0], p1 = projected[tri.i1], p2 = projected[tri.i2];
                ctx.beginPath();
                ctx.moveTo(p0.x, p0.y);
                ctx.lineTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.closePath();

                if (!wireframe) {
                    ctx.fillStyle = tri.color;
                    ctx.fill();
                }
                ctx.strokeStyle = wireframe ? '#4fc3f7' : '#222';
                ctx.lineWidth = wireframe ? 1 : 0.5;
                ctx.stroke();
            });
        }

        // Event handlers
        function setup(component) {
            htmlComponent = component;
            document.getElementById('connectionStatus').textContent = 'Connected';
            document.getElementById('connectionStatus').className = 'connection-status connected';

            htmlComponent.addEventListener('BeamCreated', () => updateStatus('Beam created in MATLAB'));
            htmlComponent.addEventListener('MeshGenerated', e => {
                document.getElementById('meshInfo').textContent = 'Nodes: ' + e.Data.numNodes + ' | Elements: ' + e.Data.numElements;
            });
            htmlComponent.addEventListener('AnalysisComplete', handleAnalysisComplete);
            htmlComponent.addEventListener('Error', e => {
                showLoading(false);
                alert('Error: ' + e.Data);
                updateStatus('Error: ' + e.Data);
            });
        }

        function handleAnalysisComplete(event) {
            showLoading(false);
            currentResults = event.Data;

            document.getElementById('resultsPanel').classList.add('visible');
            document.getElementById('maxDisp').textContent = (currentResults.maxDisplacement * 1000).toFixed(4);
            document.getElementById('maxStress').textContent = (currentResults.maxVonMises / 1e6).toFixed(2);
            document.getElementById('meshInfo').textContent = 'Nodes: ' + currentResults.numNodes + ' | Elements: ' + currentResults.numElements;

            document.getElementById('colorbar').classList.add('visible');
            document.getElementById('colorbarLabels').classList.add('visible');
            document.getElementById('cbMax').textContent = (currentResults.maxVonMises / 1e6).toFixed(1) + ' MPa';
            document.getElementById('cbMid').textContent = ((currentResults.minVonMises + currentResults.maxVonMises) / 2e6).toFixed(1) + ' MPa';
            document.getElementById('cbMin').textContent = (currentResults.minVonMises / 1e6).toFixed(1) + ' MPa';

            document.getElementById('modeIndicator').textContent = 'Mode: Results';
            updateStatus('Analysis complete - Max stress: ' + (currentResults.maxVonMises / 1e6).toFixed(2) + ' MPa');

            drawResultsMesh(currentResults);
        }

        function createBeam() {
            const L = parseFloat(document.getElementById('beamLength').value);
            const W = parseFloat(document.getElementById('beamWidth').value);
            const H = parseFloat(document.getElementById('beamHeight').value);

            if (isNaN(L) || isNaN(W) || isNaN(H) || L <= 0 || W <= 0 || H <= 0) {
                alert('Enter valid positive dimensions');
                return;
            }

            beamDims = { L, W, H };
            beamCreated = true;
            currentResults = null;

            if (htmlComponent) {
                htmlComponent.sendEventToMATLAB('CreateBeam', { length: L, width: W, height: H });
            }

            updateStatus('Beam: ' + L + ' x ' + W + ' x ' + H + ' m');
            document.getElementById('modeIndicator').textContent = 'Mode: Beam Created';
            drawBeam();
        }

        function addBC() {
            if (!beamCreated) { alert('Create beam first'); return; }
            const face = document.getElementById('bcFace').value;
            const type = document.getElementById('bcType').value;
            if (boundaryConditions.find(b => b.face === face)) { alert('BC exists on this face'); return; }
            boundaryConditions.push({ face, type });
            updateBCList();
            drawBeam();
        }

        function updateBCList() {
            document.getElementById('bcList').innerHTML = boundaryConditions.map((bc, i) =>
                '<div class="bc-item"><span>' + bc.type + ' @ ' + bc.face + '</span><button class="remove-btn" onclick="removeBC(' + i + ')">X</button></div>'
            ).join('');
        }

        function removeBC(i) { boundaryConditions.splice(i, 1); updateBCList(); drawBeam(); }

        function addLoad() {
            if (!beamCreated) { alert('Create beam first'); return; }
            const face = document.getElementById('loadFace').value;
            const fx = parseFloat(document.getElementById('forceX').value) || 0;
            const fy = parseFloat(document.getElementById('forceY').value) || 0;
            const fz = parseFloat(document.getElementById('forceZ').value) || 0;
            if (fx === 0 && fy === 0 && fz === 0) { alert('Enter non-zero force'); return; }
            loads.push({ type: 'distributed', face, fx, fy, fz });
            updateLoadList();
            drawBeam();
        }

        function updateLoadList() {
            document.getElementById('loadList').innerHTML = loads.map((ld, i) =>
                '<div class="load-item"><span>' + ld.face + ': [' + ld.fx + ',' + ld.fy + ',' + ld.fz + ']N</span><button class="remove-btn" onclick="removeLoad(' + i + ')">X</button></div>'
            ).join('');
        }

        function removeLoad(i) { loads.splice(i, 1); updateLoadList(); drawBeam(); }

        function runAnalysis() {
            if (!beamCreated) { alert('Create beam first'); return; }
            if (!boundaryConditions.length) { alert('Add boundary condition'); return; }
            if (!loads.length) { alert('Add load'); return; }
            if (!htmlComponent) { alert('Not connected to MATLAB'); return; }

            showLoading(true);
            document.getElementById('modeIndicator').textContent = 'Mode: Solving...';

            htmlComponent.sendEventToMATLAB('RunAnalysis', {
                geometry: { length: beamDims.L, width: beamDims.W, height: beamDims.H },
                material: {
                    E: parseFloat(document.getElementById('youngsModulus').value),
                    nu: parseFloat(document.getElementById('poissonsRatio').value),
                    rho: 7850
                },
                boundaryConditions: boundaryConditions,
                loads: loads,
                meshSize: document.getElementById('meshSize').value
            });
        }

        function showLoading(show) {
            document.getElementById('loadingOverlay').classList.toggle('visible', show);
        }

        function updateStatus(text) {
            document.getElementById('statusText').textContent = text;
        }

        function setView(name) {
            if (name === 'front') { viewAngleX = 0; viewAngleY = 0; }
            else if (name === 'top') { viewAngleX = Math.PI/2; viewAngleY = 0; }
            else { viewAngleX = 0.5; viewAngleY = 0.3; }
            if (currentResults) drawResultsMesh(currentResults);
            else drawBeam();
        }

        // Mouse drag for rotation
        function handleMouseDown(e) {
            isDragging = true;
            lastMouse = { x: e.clientX, y: e.clientY };
        }

        function handleMouseMove(e) {
            if (!isDragging) return;
            const dx = e.clientX - lastMouse.x;
            const dy = e.clientY - lastMouse.y;
            viewAngleY += dx * 0.01;
            viewAngleX += dy * 0.01;
            viewAngleX = Math.max(-Math.PI/2, Math.min(Math.PI/2, viewAngleX));
            lastMouse = { x: e.clientX, y: e.clientY };
            if (currentResults) drawResultsMesh(currentResults);
            else drawBeam();
        }

        function handleMouseUp() { isDragging = false; }

        function handleWheel(e) {
            viewDist += e.deltaY * 0.005;
            viewDist = Math.max(1, Math.min(10, viewDist));
            if (currentResults) drawResultsMesh(currentResults);
            else drawBeam();
            e.preventDefault();
        }

        // Init
        document.addEventListener('DOMContentLoaded', function() {
            canvas = document.getElementById('canvas3d');
            ctx = canvas.getContext('2d');

            function resize() {
                const container = canvas.parentElement;
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                if (currentResults) drawResultsMesh(currentResults);
                else drawBeam();
            }
            resize();
            window.addEventListener('resize', resize);

            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseUp);
            canvas.addEventListener('wheel', handleWheel);

            document.getElementById('createBeamBtn').addEventListener('click', createBeam);
            document.getElementById('addBCBtn').addEventListener('click', addBC);
            document.getElementById('addLoadBtn').addEventListener('click', addLoad);
            document.getElementById('runAnalysisBtn').addEventListener('click', runAnalysis);
            document.getElementById('resetViewBtn').addEventListener('click', () => setView('iso'));
            document.getElementById('viewFront').addEventListener('click', () => setView('front'));
            document.getElementById('viewTop').addEventListener('click', () => setView('top'));
            document.getElementById('viewIso').addEventListener('click', () => setView('iso'));

            document.getElementById('materialPreset').addEventListener('change', function() {
                const m = materials[this.value];
                if (m) {
                    document.getElementById('youngsModulus').value = m.E;
                    document.getElementById('poissonsRatio').value = m.nu;
                }
            });

            document.getElementById('showDeformed').addEventListener('change', () => {
                if (currentResults) drawResultsMesh(currentResults);
            });
            document.getElementById('showWireframe').addEventListener('change', () => {
                if (currentResults) drawResultsMesh(currentResults);
            });
            document.getElementById('defScale').addEventListener('input', function() {
                document.getElementById('scaleValue').textContent = this.value;
                if (currentResults) drawResultsMesh(currentResults);
            });

            drawBeam();
        });
    </script>
</body>
</html>
